{"version":3,"file":"dva-model-creator.min.js","sources":["../src/index.ts","../src/actionCreatorFactory.ts"],"sourcesContent":["import { call, put, select, take, cancel } from 'redux-saga/effects';\nimport { Action, ActionCreator } from './actionCreatorFactory';\nimport warning from 'tiny-warning/dist/tiny-warning.esm';\nimport { History } from 'history';\nimport { Dispatch } from 'redux';\n\nexport * from './actionCreatorFactory';\n\nexport interface SubscriptionAPI {\n  history: History;\n  dispatch: Dispatch<any>;\n}\n\nexport type Subscription = (api: SubscriptionAPI, done: Function) => void;\n\nexport interface SubscriptionsMapObject {\n  [key: string]: Subscription;\n}\n\nexport type Handler<InS extends OutS, OutS, P> = (state: InS, payload: P) => OutS;\n\ninterface Model<T> {\n  namespace: string;\n  state?: T;\n  reducers?: any;\n  effects?: any;\n  subscriptions?: any;\n}\n\nexport interface EffectsCommandMap {\n  put: typeof put;\n  call: typeof call;\n  select: typeof select;\n  take: typeof take;\n  cancel: typeof cancel;\n}\n\nexport type EffectsHandler<P> = (payload: P, effects: EffectsCommandMap) => IterableIterator<any>;\n\nexport type EffectsHandlerWithAction<P> = (\n  payload: Action<P>,\n  effects: EffectsCommandMap\n) => IterableIterator<any>;\n\nexport type EffectsWatcher = (effects: EffectsCommandMap) => IterableIterator<any>;\n\nexport class DvaModelBuilder<InS extends OutS, OutS = InS> {\n  private model: Model<OutS>;\n\n  constructor(initState: InS, namespace?: string) {\n    this.model = {\n      state: initState,\n      namespace,\n      effects: {},\n      reducers: {},\n      subscriptions: {},\n    };\n  }\n\n  case = <P>(actionCreator: ActionCreator<P>, handler: Handler<InS, OutS, P>) => {\n    this.checkType(actionCreator.type);\n    this.model.reducers[actionCreator.originType] = (state, action) =>\n      handler(state, action.payload);\n    return this;\n  };\n\n  caseWithAction = <P>(actionCreator: ActionCreator<P>, handler: Handler<InS, OutS, Action<P>>) => {\n    this.checkType(actionCreator.type);\n    this.model.reducers[actionCreator.originType] = handler;\n    return this;\n  };\n\n  takeEvery = <P>(actionCreator: ActionCreator<P>, handler: EffectsHandler<P>) => {\n    return this.setEffects(actionCreator, function*({ payload }, effects) {\n      yield handler(payload, effects);\n    });\n  };\n\n  takeEveryWithAction = <P>(\n    actionCreator: ActionCreator<P>,\n    handler: EffectsHandlerWithAction<P>\n  ) => {\n    return this.setEffects(actionCreator, handler);\n  };\n\n  takeLatest = <P>(actionCreator: ActionCreator<P>, handler: EffectsHandler<P>) => {\n    return this.setEffects(actionCreator, [\n      function*({ payload }, effects) {\n        yield handler(payload, effects);\n      },\n      { type: 'takeLatest' },\n    ]);\n  };\n\n  takeLatestWithAction = <P>(\n    actionCreator: ActionCreator<P>,\n    handler: EffectsHandlerWithAction<P>\n  ) => {\n    return this.setEffects(actionCreator, [handler, { type: 'takeLatest' }]);\n  };\n\n  throttle = <P>(actionCreator: ActionCreator<P>, handler: EffectsHandler<P>, ms?: number) => {\n    return this.setEffects(actionCreator, [\n      function*({ payload }, effects) {\n        yield handler(payload, effects);\n      },\n      { type: 'throttle', ms },\n    ]);\n  };\n\n  throttleWithAction = <P>(\n    actionCreator: ActionCreator<P>,\n    handler: EffectsHandlerWithAction<P>,\n    ms?: number\n  ) => {\n    return this.setEffects(actionCreator, [handler, { type: 'throttle', ms }]);\n  };\n\n  watcher = <P>(actionCreator: ActionCreator<P>, handler: EffectsWatcher) => {\n    return this.setEffects(actionCreator, [handler, { type: 'watcher' }]);\n  };\n\n  subscript = (func: Subscription) => {\n    let funcName = func.name;\n\n    warning(!!funcName, `some subscriptions in model ${this.model.namespace} don't have name`);\n    warning(!this.model.subscriptions[funcName], `duplicate  subscript function name ${funcName}`);\n\n    this.model.subscriptions[funcName] = func;\n    return this;\n  };\n\n  build = () => {\n    return this.model;\n  };\n\n  private setEffects = <P>(actionCreator: ActionCreator<P>, data: any) => {\n    this.checkType(actionCreator.type);\n    this.model.effects[actionCreator.originType] = data;\n    return this;\n  };\n\n  private checkType(type: string) {\n    const { namespace } = this.model;\n    if (namespace) {\n      const action = type.split('/');\n      warning(action.length === 2, `action ${type} in model \"${namespace}\" should have namespace`);\n      if (action.length === 2) {\n        warning(\n          action[0] === namespace,\n          `action \"${type}\" can't be effects or reducers in model \"${namespace}\"`\n        );\n      }\n    }\n  }\n}\n","export interface AnyAction {\n  type: any;\n}\n\nexport type Meta = null | { [key: string]: any };\n\nexport interface Action<Payload> extends AnyAction {\n  type: string;\n  payload: Payload;\n  error?: boolean;\n  meta?: Meta;\n}\n\n/**\n * Returns `true` if action has the same type as action creator.\n * Defines Type Guard that lets TypeScript know `payload` type inside blocks\n * where `isType` returned `true`.\n *\n * @example\n *\n *    const somethingHappened =\n *      actionCreator<{foo: string}>('SOMETHING_HAPPENED');\n *\n *    if (isType(action, somethingHappened)) {\n *      // action.payload has type {foo: string}\n *    }\n */\nexport function isType<Payload>(\n  action: AnyAction,\n  actionCreator: ActionCreator<Payload>\n): action is Action<Payload> {\n  return action.type === actionCreator.type;\n}\n\ntype VoidToOptional<P> = P extends void ? P | undefined : P;\n\nexport type ActionCreator<Payload> = {\n  type: string;\n  originType: string;\n  match: (action: AnyAction) => action is Action<Payload>;\n  (payload: VoidToOptional<Payload>, meta?: Meta): Action<Payload>;\n};\n\ntype OptionalError<Error> = Error extends void\n  ? {\n      error?: Error;\n    }\n  : {\n      error: Error;\n    };\n\ntype OptionalParams<Params> = Params extends void\n  ? {\n      params?: Params;\n    }\n  : {\n      params: Params;\n    };\n\ntype OptionalResult<Result> = Result extends void\n  ? {\n      result?: Result;\n    }\n  : {\n      result: Result;\n    };\n\nexport type Success<Params, Result> = OptionalResult<Result> & OptionalParams<Params>;\n\nexport type Failure<Params, Error> = OptionalError<Error> & OptionalParams<Params>;\n\nexport interface AsyncActionCreators<Params, Result, Error = {}> {\n  type: string;\n  started: ActionCreator<Params>;\n  done: ActionCreator<Success<Params, Result>>;\n  failed: ActionCreator<Failure<Params, Error>>;\n}\n\nexport interface ActionCreatorFactory {\n  <Payload = void>(type: string, commonMeta?: Meta, isError?: boolean): ActionCreator<Payload>;\n\n  <Payload = void>(\n    type: string,\n    commonMeta?: Meta,\n    isError?: (payload: Payload) => boolean\n  ): ActionCreator<Payload>;\n\n  async<Params, Result, Error = {}>(\n    type: string,\n    commonMeta?: Meta\n  ): AsyncActionCreators<Params, Result, Error>;\n}\n\ndeclare const process: {\n  env: {\n    NODE_ENV?: string;\n  };\n};\n\nexport function actionCreatorFactory(\n  prefix?: string | null,\n  defaultIsError: (payload: any) => boolean = p => p instanceof Error\n): ActionCreatorFactory {\n  const actionTypes: { [type: string]: boolean } = {};\n\n  const base = prefix ? `${prefix}/` : '';\n\n  function actionCreator<Payload>(\n    type: string,\n    commonMeta?: Meta,\n    isError: ((payload: Payload) => boolean) | boolean = defaultIsError\n  ) {\n    const fullType = base + type;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (actionTypes[fullType]) throw new Error(`Duplicate action type: ${fullType}`);\n\n      actionTypes[fullType] = true;\n    }\n\n    return Object.assign(\n      (payload: Payload, meta?: Meta) => {\n        const action: Action<Payload> = {\n          type: fullType,\n          payload,\n        };\n\n        if (commonMeta || meta) {\n          action.meta = Object.assign({}, commonMeta, meta);\n        }\n\n        if (isError && (typeof isError === 'boolean' || isError(payload))) {\n          action.error = true;\n        }\n\n        return action;\n      },\n      {\n        type: fullType,\n        toString: () => fullType,\n        originType: type,\n        match: (action: AnyAction): action is Action<Payload> => action.type === fullType,\n      }\n    ) as ActionCreator<Payload>;\n  }\n\n  function asyncActionCreators<Params, Result, Error>(\n    type: string,\n    commonMeta?: Meta\n  ): AsyncActionCreators<Params, Result, Error> {\n    return {\n      type: base + type,\n      started: actionCreator<Params>(`${type}_STARTED`, commonMeta, false),\n      done: actionCreator<Success<Params, Result>>(`${type}_DONE`, commonMeta, false),\n      failed: actionCreator<Failure<Params, Error>>(`${type}_FAILED`, commonMeta, true),\n    };\n  }\n\n  return Object.assign(actionCreator, { async: asyncActionCreators });\n}\n\nexport default actionCreatorFactory;\n"],"names":["initState","namespace","this","actionCreator","handler","_this","checkType","type","model","reducers","originType","state","action","payload","setEffects","_a","effects","_b","ms","func","funcName","name","subscriptions","data","DvaModelBuilder","split","prefix","defaultIsError","p","Error","base","commonMeta","isError","fullType","Object","assign","meta","error","toString","match","async","started","done","failed"],"mappings":"mwCAiDE,WAAYA,EAAgBC,GAA5B,WAUAC,UAAO,SAAIC,EAAiCC,GAI1C,OAHAC,EAAKC,UAAUH,EAAcI,MAC7BF,EAAKG,MAAMC,SAASN,EAAcO,YAAc,SAACC,EAAOC,GACtD,OAAAR,EAAQO,EAAOC,EAAOC,UACjBR,GAGTH,oBAAiB,SAAIC,EAAiCC,GAGpD,OAFAC,EAAKC,UAAUH,EAAcI,MAC7BF,EAAKG,MAAMC,SAASN,EAAcO,YAAcN,EACzCC,GAGTH,eAAY,SAAIC,EAAiCC,GAC/C,OAAOC,EAAKS,WAAWX,EAAe,SAAUY,EAAaC,OAAXH,6DAChD,SAAMT,EAAQS,EAASG,kBAAvBC,mBAIJf,yBAAsB,SACpBC,EACAC,GAEA,OAAOC,EAAKS,WAAWX,EAAeC,IAGxCF,gBAAa,SAAIC,EAAiCC,GAChD,OAAOC,EAAKS,WAAWX,EAAe,CACpC,SAAUY,EAAaC,OAAXH,6DACV,SAAMT,EAAQS,EAASG,kBAAvBC,iBAEF,CAAEV,KAAM,iBAIZL,0BAAuB,SACrBC,EACAC,GAEA,OAAOC,EAAKS,WAAWX,EAAe,CAACC,EAAS,CAAEG,KAAM,iBAG1DL,cAAW,SAAIC,EAAiCC,EAA4Bc,GAC1E,OAAOb,EAAKS,WAAWX,EAAe,CACpC,SAAUY,EAAaC,OAAXH,6DACV,SAAMT,EAAQS,EAASG,kBAAvBC,iBAEF,CAAEV,KAAM,WAAYW,SAIxBhB,wBAAqB,SACnBC,EACAC,EACAc,GAEA,OAAOb,EAAKS,WAAWX,EAAe,CAACC,EAAS,CAAEG,KAAM,WAAYW,SAGtEhB,aAAU,SAAIC,EAAiCC,GAC7C,OAAOC,EAAKS,WAAWX,EAAe,CAACC,EAAS,CAAEG,KAAM,cAG1DL,eAAY,SAACiB,GACX,IAAIC,EAAWD,EAAKE,KAMpB,OADAhB,EAAKG,MAAMc,cAAcF,GAAYD,EAC9Bd,GAGTH,WAAQ,WACN,OAAOG,EAAKG,OAGNN,gBAAa,SAAIC,EAAiCoB,GAGxD,OAFAlB,EAAKC,UAAUH,EAAcI,MAC7BF,EAAKG,MAAMQ,QAAQb,EAAcO,YAAca,EACxClB,GAzFPH,KAAKM,MAAQ,CACXG,MAAOX,EACPC,YACAe,QAAS,GACTP,SAAU,GACVa,cAAe,IAoGrB,OAbUE,sBAAR,SAAkBjB,GACR,IAAAN,uBACR,GAAIA,EACaM,EAAKkB,MAAM,+DC7C9BC,EACAC,gBAAAA,WAA4CC,GAAK,OAAAA,aAAaC,QAI9D,IAAMC,EAAOJ,EAAYA,MAAY,GAErC,SAASvB,EACPI,EACAwB,EACAC,gBAAAA,KAEA,IAAMC,EAAWH,EAAOvB,EAQxB,OAAO2B,OAAOC,OACZ,SAACtB,EAAkBuB,GACjB,IAAMxB,EAA0B,CAC9BL,KAAM0B,EACNpB,WAWF,OARIkB,GAAcK,KAChBxB,EAAOwB,KAAOF,OAAOC,OAAO,GAAIJ,EAAYK,IAG1CJ,IAA+B,kBAAZA,GAAyBA,EAAQnB,MACtDD,EAAOyB,OAAQ,GAGVzB,GAET,CACEL,KAAM0B,EACNK,SAAU,WAAM,OAAAL,GAChBvB,WAAYH,EACZgC,MAAO,SAAC3B,GAAiD,OAAAA,EAAOL,OAAS0B,KAiB/E,OAAOC,OAAOC,OAAOhC,EAAe,CAAEqC,MAZtC,SACEjC,EACAwB,GAEA,MAAO,CACLxB,KAAMuB,EAAOvB,EACbkC,QAAStC,EAAyBI,aAAgBwB,GAAY,GAC9DW,KAAMvC,EAA0CI,UAAawB,GAAY,GACzEY,OAAQxC,EAAyCI,YAAewB,GAAY,0BA9HhFnB,EACAT,GAEA,OAAOS,EAAOL,OAASJ,EAAcI"}